use!(
    module!("common.precedence"),
);

pattern + {arg} :: positive(LeftUnaryPrecedence);
pattern - {arg} :: negative(LeftUnaryPrecedence);
-- TODO Alias differently?
pattern not {arg} :: not_f(LeftUnaryPrecedence);

pattern {lhs} ** {rhs} :: exponent(ExponentiationPrecedence);

pattern {lhs} * {rhs} :: multiply(MultiplicationPrecedence);
pattern {lhs} / {rhs} :: divide(MultiplicationPrecedence);
pattern {lhs} % {rhs} :: modulo(MultiplicationPrecedence);

pattern {lhs} + {rhs} :: add(AdditionPrecedence);
pattern {lhs} - {rhs} :: subtract(AdditionPrecedence);

pattern {lhs} == {rhs} :: is_equal(ComparisonPrecedence);
pattern {lhs} != {rhs} :: is_not_equal(ComparisonPrecedence);
pattern {lhs} > {rhs} :: is_greater(ComparisonPrecedence);
pattern {lhs} >= {rhs} :: is_greater_or_equal(ComparisonPrecedence);
pattern {lhs} < {rhs} :: is_lesser(ComparisonPrecedence);
pattern {lhs} <= {rhs} :: is_lesser_or_equal(ComparisonPrecedence);

-- TODO Alias differently?
pattern {lhs} and {rhs} :: and_f(LogicalConjunctionPrecedence);

-- TODO Alias differently?
pattern {lhs} or {rhs} :: or_f(LogicalDisjunctionPrecedence);
