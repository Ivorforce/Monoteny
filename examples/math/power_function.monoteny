-- power functions are a great way to calculate compatible functions in O(log n)
def power(initial_element: '#T, n: '$UInt, operator: 'Fn(#T, #T) -> #T) :: {
    var n = n;
    var power_element = initial_element;
    var result = initial_element;
    while n != 0 :: {
        upd power_element = operator(power_element, power_element);

        if n.bit_and(1) != 0 :: result = operator(result, power_element);

        upd n = n.bitshift_right(1);
    };
    return result;
};

def fibonacci(n '$UInt) -> $UInt :: power(
    initial_element: [[1, 1], [1, 0]],
    n: n - 1,
    operator: (*),
 )@[0, 0];

def {$Int} ** {$Int} -> $Int :: {
    if rhs == 0 :: return 1;

    if rhs > 0 :: {
        return power(
           initial_element: lhs,
           n: IntNU(rhs - 1),
           operator: (*),
        );
    };
    else :: return 0;  -- As is custom, integers round down.
};

def {$Int} * {$Int} -> $Int :: {
    if rhs == 0 :: return 0;

    if rhs > 0 :: {
        return power(
           initial_element: lhs,
           n: IntNU(rhs - 1),
           operator: (+),
        );
    };
    else :: {
        return -power(
           initial_element: lhs,
           n: IntNU(-(rhs - 1)),
           operator: (+),
        );
    };
};
