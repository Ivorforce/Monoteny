-- power functions are a great way to calculate compatible functions in O(log n)
def power(initial_element: '#T, n: '$Natural, operator: 'Fn(#T, #T) -> #T) :: {
    var n = n;
    var power_element = initial_element;
    var result = initial_element;
    while n != 0 :: {
        upd power_element = operator(power_element, power_element);

        if n.bit_and(1) != 0 :: result = operator(result, power_element);

        upd n = n.bitshift_right(1);
    };
    return result;
};

def fibonacci(n '$Natural) -> $Natural :: power(
    initial_element: [[1, 1], [1, 0]],
    n: n - 1,
    operator: (*),
 )@[0, 0];

def pow(base '$Int, exponent '$Int) -> $Int :: {
    if exponent == 0 :: return 1;

    if base > 0 :: {
        return power(
           initial_element: base,
           n: NaturalN(exponent - 1),
           operator: (*),
        );
    };
    else :: return 0;  -- As is custom, integers round down.
};

def multiply(lhs '$Int, rhs '$Int) -> $Int :: {
    if rhs == 0 :: return 0;

    if rhs > 0 :: {
        return power(
           initial_element: lhs,
           n: NaturalN(rhs - 1),
           operator: (+),
        );
    };
    else :: {
        return -power(
           initial_element: lhs,
           n: NaturalN(-(rhs - 1)),
           operator: (+),
        );
    };
};
