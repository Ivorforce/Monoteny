global {: (N: <Addition>) :} {
    fn times_two: (_ arg: N) -> N = {
        arg + arg
    }
}

extension {: (N: <Addition>) = N :} {
    fn times_two: () -> N = {
        self + self
    }
}

extension {: (A: <Any>, Index: <LeftBound>) = A[Index] :} {
    // A fun example of where compile-time complexity is as hard as the function itself.
    fn skip_first: (_ skip_count: Int32) -> {:
        guard let .Known(left_bound) = Index.left_bound else {
            throw "Left bound must be known for non-optional skipping.";
        }

        guard let .Known(skip_count) = skip_count else {
            throw "Cannot skip with a count unknown at compile-time.";
        }

        guard skip_count >= Count.count else {
            throw format("Cannot skip more elements than available: {} > {}", skip_count, left_bound);
        }

        // Index could be right bound or open!
        // Just re-use the index definition with a minor tweak.
        var new_index = Index.clone();
        new_index.left_bound = left_bound + skip_count;

        return A[new_index];
    :} = {
        self@[self@.index.left_bound + skip_count...];
    }

    fn skip_first: (_ skip_count: Int32) -> {:
        guard .Unknown == Index.left_bound || .Unknown == skip_count else {
            throw "A known left bound and skip count can be evaluated directly to a non-optional.";
        }

        return Option<A[Index]>;
    :} = {
        self?@[self@.index.left_bound + skip_count...];
    }
}
