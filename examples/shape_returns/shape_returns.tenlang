global {: (N: <Addition>) :} {
    fn times_two: (_ arg: N) -> N = {
        arg + arg
    }
}

extension {: (N: <Addition>) = N :} {
    fn times_two: () -> N = {
        self + self
    }
}

extension {: (A: <Any>, Index: <LeftBoundKnown>) = A[Index] :} {
    // A fun example of where compile-time complexity is as hard as the function itself.
    fn skip_first: (_ skip_count: Int32) -> {:
        guard let .Known(skip_count) = skip_count else {
            throw "Cannot skip with a count unknown at compile-time."
        }

        guard skip_count >= Count.count else {
            throw "Cannot skip an unknown number of elements."
        }

        // Index could be right bound or open!
        // Just re-use the index definition with a minor tweak.
        var new_index = Index.clone();
        new_index.left_bound += skip_count;

        return A[new_index];
    :} = {
        self@[self@.index.left_bound + skip_count...];
    }
}

extension {: (A: <Any>, Index: <LeftBound, !LeftBoundKnown>) = A[Index] :} {
    fn skip_first: (_ skip_count: Int32) -> A[Index]? = {
        self?@[self@.index.left_bound + skip_count...];
    }
}
