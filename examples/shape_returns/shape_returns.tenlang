global {: (N: <Addition>) :} {
    fn times_two: (_ arg: N) -> N = {
        arg + arg
    }
}

extension {: (N: <Addition>) = N :} {
    fn times_two: () -> N = {
        self + self
    }
}

extension {: (A: <Any>, Index: <LeftBound>) = A[Index] :} {
    // A fun example of where compile-time complexity is as hard as
    fn skip_first: (_ skip_count: Int32 ) -> {:
        guard let .Known(skip_count) = skip_count else {
            throw "Cannot skip with a count unknown at compile-time."
        }

        guard skip_count >= Count.count else {
            throw "Cannot skip an unknown number of elements."
        }

        return A[Index.left_bound + skip_count...];
    :} = {
        self@[self@.index.left_bound + skip_count...];
    }
}
