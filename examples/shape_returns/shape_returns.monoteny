-- A skip_first function with a generically complex return type.
def {#Unit[$LeftBoundIndex]}.skip_first(_: skip_count 'Int32) {:
    () :: \.self@[>| skip_count];
:}

-- Using static types instead of letting the compiler infer them.
def {#Unit[$LeftBoundIndex]}.skip_first(_: skip_count 'Int32) {:
    -- A fun example of where compile-time complexity is as hard as the function itself.
    guard
        let .Known(left_bound) = $LeftBoundIndex.left_bound,
        let .Known(skip_count) = skip_count
    else {
        return () -> Option<$Unit[$LeftBoundIndex]> :: self@[self@.index.left_bound + skip_count...]?;
    }

    guard skip_count <= Count.count else {
        throw format("Cannot skip more elements than available: {} > {}", skip_count, left_bound);
    }

    -- Index could be right bound or open!
    -- Just re-use the index definition with a minor tweak.

     var new_index = $LeftBoundIndex;
     new_index.left_bound = new_start;
     return () -> $Unit[new_index] :: self@[new_start...];
:}
