-- import(monoteny.dialects.common.0.0);

def {$Number}.square() -> $Number :: self * self;

declare List<Float> as Summable {
    def {Self}.sum() :: self.reduce(+);
}

declare MyList as Collection<Float> {
    def {Self}.count -> $Int :: self.list.count;
}

def add(element: $Float, to_list: List<super $Float>) :: to_list.push(element);

@main
def main() :: {
    print(2.square() ** 3 'Float32);
}

@transpile
def transpile(transpiler 'Transpiler) :: {
    -- The idea is that if we transpile this and run it, it should yield the same output
    -- as if running using the interpreter.

    -- Ideally, constant folding can break it down to just print statements.
    transpiler.add(main);
}
