use!(module!("common"));

-- Make a pattern: `a /_ b` calls `floor_div(lhs: <>, rhs: <>)`
pattern {lhs} /_ {rhs} :: floor_div(MultiplicationPrecedence);

-- Define a function floor_div(lhs '$Real, rhs: $Real) using the pattern we set before.
def {$Real} /_ {$Real} -> $Real :: floor(lhs / rhs);

-- Define a function on numbers.
def {$Number}.square() -> $Number :: self * self;

-- Define a 'static' function on numbers.
def square(value: '$Number) -> $Number :: value.square();

-- Define pi_ish as an overloaded constant. For floats, it's 3.14. For ints, it's 3.
-- Depending on the caller, using this 'constant' is going to yield different values.
def pi_ish -> $Real :: 3.14;
def pi_ish -> $Int :: 3;

def main! :: {
    -- Print string
    write_line("Test: \"Success\"");

    -- 'value' is not bound yet. It could be any $Real!
    let value = 2.2.square() * sin(e);
    write_line("Value: \(value)");

    -- Bind 'value' implicitly by binding b to Float32.
    var b 'Float32 = square(value:) + pi_ish;
    upd b = b.square() ** -2.2 /_ value + tau;

    -- Use pi_ish for ints, which yields 3.
    var c 'Int32 = pi_ish / 2;

    -- Print boolean
    write_line("Bool Value: \(b < 2 and not (value > 2) and true)");
};

def transpile! :: {
    -- The idea is that if we transpile this and run it, it should yield the same output
    -- as if running using the interpreter.

    -- Ideally, constant folding can break it down to just print statements.
    transpiler.add(main);
};
