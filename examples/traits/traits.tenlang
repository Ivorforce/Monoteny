trait Twiceable<_ $Number> {
    abstract fun $Number.twice: $Number;
}

// Introduce a generic on which Addition must be declared.
// All functions inside a given() {} statement must expose the generics somewhere in their interface.
given <Number> where Addition<Number> {
    // When encountering a declaration, check that all required functions exist.
    // It finds the below function, which matches the trait declaration.
    declare Twiceable<Number>;

    // A polymorphic function that runs on numbers that can do addition.
    // This is, by itself, independent of Twiceable's function.
    // abstract function '+' is matched by the linker because Number is of type 'Addition'.
    // This results in a dynamic function call.
    fun {self: Number}.twice: Number :: self + self;
}

// Anonymous generics: $Number implies that the generic conforms to the trait,
// as if writing: given <$Number> where Number<$Number>.
fun {self: $Number}.times_4: $Number :: self.twice.twice;

fun main() :: {
    // Linker finds function 'twice' declared above because 5 conforms to Addition.
    // It does not find abstract function 'twice' because 5 is it of declared type Twiceable.
    // This results in a static function call.
    let a: Int32 = 5.twice;  // yields 10

    // Addition<Int32> is declared (builtin).
    // -> Twiceable<Int32> is declared.
    // Linker function 'times_4' declared above because of this.
    // This results in a static function call, wherein 'twice' is called dynamically.
    let b: Int32 = 5.times_4;  // yields 20
}
