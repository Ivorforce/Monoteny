use std::str::FromStr;
use crate::parser::abstract_syntax::*;
use crate::program::types::*;
use crate::program::allocation::*;
use crate::program::functions::ParameterKey;

grammar;

// =============================== Lexer Precedence =====================================

match {
    // so i heard u like regex
    r"([$#])?[a-zA-Z_]\w*" => _Identifier,
    r"[!+\-*/&%=><|.^?][!+\-*/&%=><|.^?_]*" => _OperatorIdentifier,
    r"[0-9]+(\.[0-9]*)?" => _Number,
    "return",
    ".", "'",
    "(", ")", "{", "}", "[",  "]", "..",
    ";", ",", ":", "::", "->",
    "=",
    "let", "var", "upd",
    "def", "pattern",
    "if",
    _
}

// =============================== Primitive =====================================

Identifier: String = {
    _Identifier => format!("{}", <>),
};

OperatorIdentifier: String = {
    _OperatorIdentifier => format!("{}", <>),
};

AnyIdentifier: String = {
    Identifier,
    OperatorIdentifier,
};

Number: String = {
    _Number => format!("{}", <>)
};

// =============================== Global =====================================


pub Program: Program = {
    <stmts: GlobalStatement*> => Program { global_statements: stmts }
};

pub GlobalStatement: Box<GlobalStatement> = {
    Function => Box::new(GlobalStatement::FunctionDeclaration(<>)),
    Pattern => Box::new(GlobalStatement::Pattern(<>)),
    OperatorFunction => Box::new(GlobalStatement::Operator(<>)),
};

Pattern: Box<PatternDeclaration> = {
    "pattern" <alias: Identifier> "(" <precedence: Identifier> ")" "::" <parts: PatternPart+> ";" => Box::new(PatternDeclaration { <> }),
}

PatternPart: Box<PatternPart> = {
    AnyIdentifier => Box::new(PatternPart::Keyword(<>)),
    "{" <key: AnyIdentifier> ":" <internal_name: AnyIdentifier> "}" => Box::new(PatternPart::Parameter { key: ParameterKey::from_string(key), internal_name }),
    "{" <key: AnyIdentifier> "}" => Box::new(PatternPart::Parameter { key: ParameterKey::from_string(key.clone()), internal_name: key }),
}

Function: Box<Function> = {
    "def" <target_type: (<ContextualParameter> ".")?> <identifier: Identifier> "(" <parameters: OptionalFinalSeparatorList<KeyedParameter, ",">> ")" <return_type: ("->" <Expression>)?> "::" <body: FunctionBody> => Box::new(Function { <> }),
}

OperatorFunction: Box<OperatorFunction> = {
    "def" <parts: OperatorArgument+> <return_type: ("->" <Expression>)?> "::" <body: FunctionBody> => Box::new(OperatorFunction { <> }),
}

OperatorArgument: Box<OperatorArgument> = {
    AnyIdentifier => Box::new(OperatorArgument::Keyword(<>)),
    ContextualParameter => Box::new(OperatorArgument::Parameter(<>)),
}

ContextualParameter: Box<Expression> = {
    "{" <param_type: Expression> "}" => Box::new(param_type),
}

FunctionBody: Vec<Box<Statement>> = {
    "{" <(<Statement> ";")*> "}",
    <Expression> ";" => vec![Box::new(Statement::Return(Some(<>)))],
}

KeyedParameter: Box<KeyedParameter> = {
    <internal_name: Identifier> "'" <param_type: Expression> => Box::new(KeyedParameter {
        key: ParameterKey::Name(internal_name.clone()), internal_name, param_type
    }),
    <key: Identifier> ":" <internal_name: Identifier> "'" <param_type: Expression> => Box::new(KeyedParameter {
        key: ParameterKey::from_string(key), internal_name, param_type
    }),
}


// =============================== Statement =====================================


pub Statement: Box<Statement> = {
    <mutability: VariableDeclarationMutability> <identifier: Identifier> <type_declaration: ("'" <Expression>)?> "=" <expression: Expression> => Box::new(Statement::VariableDeclaration { mutability, identifier, type_declaration, expression }),
    "upd" <variable_name: Identifier> "=" <new_value: Expression> => Box::new(Statement::VariableAssignment { variable_name, new_value }),
    "return" <Expression?> => Box::new(Statement::Return(<>)),
    Expression => Box::new(Statement::Expression(<>)),
};

VariableDeclarationMutability: Mutability = {
    "let" => Mutability::Immutable,
    "var" => Mutability::Mutable,
};

// =============================== Expression =====================================

Expression: Expression = {
    TypedTerm+
};

TypedTerm: Box<Term> = {
    <object: Term> "'" <type_: TypedTerm> => Box::new(Term::TypeHint { <> }),
    Term
}

Term: Box<Term> = {
    AnyIdentifier => Box::new(Term::Identifier(<>)),
    Number => Box::new(Term::Number(<>)),
    "[" <OptionalFinalSeparatorList<ArrayArgument, ",">> "]" => Box::new(Term::Array(<>)),
    "(" <OptionalFinalSeparatorList<StructArgument, ",">> ")" => Box::new(Term::Struct(<>)),
    <target: Term> "." <member_name: Identifier> => Box::new(Term::MemberAccess { <> }),
    r"\x22[^\x22]*\x22" => {
        let s = <>;
        Box::new(Term::StringLiteral(String::from(&s[1..(s.len() - 1)])))
    },
};

StructArgument: StructArgument = {
    <key: Identifier> ":" <value: Expression> => StructArgument { key: ParameterKey::Name(key), value },
    <value: Expression> => StructArgument { key: ParameterKey::Positional, value }
}

ArrayArgument: ArrayArgument = {
    <key: Expression> ":" <value: Expression> => ArrayArgument { key: Some(key), value },
    <value: Expression> => ArrayArgument { key: None, value }
}

// =============================== Util =====================================

OptionalFinalSeparatorList<Element, Separator>: Vec<Element> = {
    <v0: (<Element> Separator)*> <e1: Element?> => v0.into_iter().chain(e1).collect()
};
