use std::str::FromStr;
use crate::parser::ast::*;
use crate::parser::strings::REGEX_UNESCAPE;
use crate::program::types::*;
use crate::program::allocation::*;
use crate::program::functions::ParameterKey;

grammar;


// =============================== Lexer Precedence =====================================

match {
    r"\s*" => { },  // whitespace
    r"--[^\n\r]*[\n\r]*" => { }, // line comment
} else {
    // so i heard u like regex
    r"[a-zA-Z_$#][\w$#]*" => _Identifier,
    r"[!+\-*/&%=><|.^?][!+\-*/&%=><|.^?_]*" => _OperatorIdentifier,
    r"[0-9]+" => _Int,
    r"[0-9]+\.[0-9]+" => _Float,
    ".", "'",
    "(", ")", "{", "}", "[",  "]", "..",
    ";", ",", ":", "::", "->",
    "=",
    "def", "pattern", "declare", "trait",
    "let", "var", "upd",
    "if", "is",
    "return",
    _
}

// =============================== Primitive =====================================

Identifier: String = {
    _Identifier => format!("{}", <>),
};

OperatorIdentifier: String = {
    _OperatorIdentifier => format!("{}", <>),
};

AnyIdentifier: String = {
    Identifier,
    OperatorIdentifier,
};

Int: String = {
    _Int => format!("{}", <>)
};

Float: String = {
    _Float => format!("{}", <>)
};

// =============================== Global =====================================


pub Program: Module = {
    <stmts: (<GlobalStatement> ";")*> => Module { global_statements: stmts }
};

pub GlobalStatement: Box<GlobalStatement> = {
    Function => Box::new(GlobalStatement::FunctionDeclaration(<>)),
    Pattern => Box::new(GlobalStatement::Pattern(<>)),
    OperatorFunction => Box::new(GlobalStatement::Operator(<>)),
    Trait => Box::new(GlobalStatement::Trait(<>)),
    Conformance => Box::new(GlobalStatement::Conformance(<>)),
};

Pattern: Box<PatternDeclaration> = {
    "pattern" <alias: Identifier> "(" <precedence: Identifier> ")" "::" <parts: PatternPart+> => Box::new(PatternDeclaration { <> }),
}

PatternPart: Box<PatternPart> = {
    AnyIdentifier => Box::new(PatternPart::Keyword(<>)),
    "{" <name_value: NameValuePair> "}" => Box::new(PatternPart::Parameter { key: name_value.0, internal_name: name_value.1 }),
}

Function: Box<Function> = {
    <decorators: Decorator*> "def" <target_type: (<ContextualParameter> ".")?> <identifier: Identifier> "(" <parameters: OptionalFinalSeparatorList<KeyedParameter, ",">> ")" <return_type: ("->" <Expression>)?> <body: ("::" <FunctionBody>)?> => Box::new(Function { <> }),
}

OperatorFunction: Box<OperatorFunction> = {
    <decorators: Decorator*> "def" <parts: OperatorArgument+> <return_type: ("->" <Expression>)?> <body: ("::" <FunctionBody>)?> => Box::new(OperatorFunction { <> }),
}

Decorator: String = {
    "@" <Identifier>
}

OperatorArgument: Box<OperatorArgument> = {
    AnyIdentifier => Box::new(OperatorArgument::Keyword(<>)),
    ContextualParameter => Box::new(OperatorArgument::Parameter(<>)),
}

ContextualParameter: Box<Expression> = {
    "{" <param_type: Expression> "}" => Box::new(param_type),
}

FunctionBody: Expression = {
    <Expression>,
}

KeyedParameter: Box<KeyedParameter> = {
    <name_value: NameValuePair> "'" <param_type: Expression> => Box::new(KeyedParameter {
        key: name_value.0, internal_name: name_value.1, param_type
    }),
}

NameValuePair: (ParameterKey, String) = {
    <name: Identifier> ":" <value: Identifier> => (ParameterKey::Name(name), value),
    <name: Identifier> ":" => (ParameterKey::Name(name.clone()), name),
    <value: Identifier> => (ParameterKey::Positional, value),
}

// =============================== Trait =====================================

Trait: Box<TraitDefinition> = {
    <decorators: Decorator*> "trait" <name: Identifier> "{" <statements: (<GlobalStatement> ";")*> "}" => Box::new(TraitDefinition { <> }),
}

Conformance: Box<TraitConformanceDeclaration> = {
    "declare" <target: Identifier> "is" <trait_: Identifier> "{" <statements: (<GlobalStatement> ";")*> "}" => Box::new(TraitConformanceDeclaration { <> }),
}

// =============================== Statement =====================================


pub Statement: Box<Statement> = {
    <mutability: VariableDeclarationMutability> <identifier: Identifier> <type_declaration: ("'" <Expression>)?> "=" <expression: Expression> => Box::new(Statement::VariableDeclaration { mutability, identifier, type_declaration, expression }),
    "upd" <variable_name: Identifier> "=" <new_value: Expression> => Box::new(Statement::VariableAssignment { variable_name, new_value }),
    "return" <Expression?> => Box::new(Statement::Return(<>)),
    Expression => Box::new(Statement::Expression(<>)),
};

VariableDeclarationMutability: Mutability = {
    "let" => Mutability::Immutable,
    "var" => Mutability::Mutable,
};

// =============================== Expression =====================================

Expression: Expression = {
    Term+ => Expression::from(<>)
};

Term: Box<Term> = {
    AnyIdentifier => Box::new(Term::Identifier(<>)),
    Int => Box::new(Term::Int(<>)),
    Float => Box::new(Term::Float(<>)),
    "[" <OptionalFinalSeparatorList<ArrayArgument, ",">> "]" => Box::new(Term::Array(<>)),
    "(" <OptionalFinalSeparatorList<StructArgument, ",">> ")" => Box::new(Term::Struct(<>)),
    <target: Term> "." <member_name: Identifier> => Box::new(Term::MemberAccess { <> }),
    r"\x22(?:[^\x22\\]|\\.)*\x22" => {
        let s = <>;
        Box::new(Term::StringLiteral(REGEX_UNESCAPE.replace_all(&s[1..(s.len() - 1)], "$1").to_string()))
    },
    "{" <(<Statement> ";")*> "}" => Box::new(Term::Scope(<>)),
};

StructArgument: StructArgument = {
    <key: Identifier> ":" <value: Expression> <type_declaration: ("'" <Expression>)?> => StructArgument { key: ParameterKey::Name(key), value, type_declaration },
    <value: Expression> <type_declaration: ("'" <Expression>)?> => StructArgument { key: ParameterKey::Positional, value, type_declaration },
    <key: Identifier> ":" => StructArgument { key: ParameterKey::Name(key.clone()), value: Expression::from(vec![Box::new(Term::Identifier(key))]), type_declaration: None },  // TODO Maybe better handled post-syntax?
}

ArrayArgument: ArrayArgument = {
    <key: Expression> ":" <value: Expression> <type_declaration: ("'" <Expression>)?> => ArrayArgument { key: Some(key), value, type_declaration },
    <value: Expression> <type_declaration: ("'" <Expression>)?>=> ArrayArgument { key: None, value, type_declaration }
}

// =============================== Util =====================================

OptionalFinalSeparatorList<Element, Separator>: Vec<Element> = {
    <v0: (<Element> Separator)*> <e1: Element?> => v0.into_iter().chain(e1).collect()
};
