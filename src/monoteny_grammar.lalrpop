use lalrpop_util::ErrorRecovery;
use std::str::FromStr;
use crate::parser::ast::*;
use crate::parser::lexer::*;
use crate::parser::error::*;
use crate::program::types::*;
use crate::program::allocation::*;
use crate::program::functions::ParameterKey;

grammar<'i, 'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'i>, Error>>, text: &'i str);

extern {
    type Location = usize;
    type Error = Error;

    enum Token<'i> {
        _Identifier => Token::Identifier(_),
        _OperatorIdentifier => Token::OperatorIdentifier(_),
        _IntLiteral => Token::IntLiteral(_),
        _RealLiteral => Token::RealLiteral(_),
        StringLiteral => Token::StringLiteral(_),

        "def" => Token::Symbol("def"),
        "pattern" => Token::Symbol("pattern"),
        "trait" => Token::Symbol("trait"),
        "declare" => Token::Symbol("declare"),

        "{" => Token::Symbol("{"),
        "}" => Token::Symbol("}"),
        "(" => Token::Symbol("("),
        ")" => Token::Symbol(")"),
        "[" => Token::Symbol("["),
        "]" => Token::Symbol("]"),
        "::" => Token::Symbol("::"),
        ":" => Token::Symbol(":"),
        "@" => Token::Symbol("@"),
        "'" => Token::Symbol("'"),
        "=" => Token::Symbol("="),
        "," => Token::Symbol(","),
        ";" => Token::Symbol(";"),
        "." => Token::Symbol("."),
        "->" => Token::Symbol("->"),
        "\"" => Token::Symbol("\""),

        "let" => Token::Symbol("let"),
        "var" => Token::Symbol("var"),
        "upd" => Token::Symbol("upd"),
        "return" => Token::Symbol("return"),

        "is" => Token::Symbol("is"),
    }
}

// =============================== Primitive =====================================

Identifier: String = { _Identifier => <>.to_string() };
OperatorIdentifier: String = { _OperatorIdentifier => <>.to_string(), };
IntLiteral: String = { _IntLiteral => <>.to_string() };
RealLiteral: String = { _RealLiteral => <>.to_string() };

AnyIdentifier: String = {
    Identifier,
    OperatorIdentifier,
};


// =============================== Global =====================================


pub Program: Module = {
    <stmts: (<GlobalStatement> ";")*> => Module { global_statements: stmts }
};

pub GlobalStatement: Box<GlobalStatement> = {
    Function => Box::new(GlobalStatement::FunctionDeclaration(<>)),
    Pattern => Box::new(GlobalStatement::Pattern(<>)),
    OperatorFunction => Box::new(GlobalStatement::Operator(<>)),
    Trait => Box::new(GlobalStatement::Trait(<>)),
    Conformance => Box::new(GlobalStatement::Conformance(<>)),
    GlobalMacro => Box::new(GlobalStatement::Macro(<>)),
    <start:@L> <e: !> <end:@R> => { errors.push(e.clone()); Box::new(GlobalStatement::Error(derive_error(&e, start, end))) },
};

Pattern: Box<PatternDeclaration> = {
    "pattern" <alias: Identifier> "(" <precedence: Identifier> ")" "::" <parts: PatternPart+> => Box::new(PatternDeclaration { <> }),
}

PatternPart: Box<PatternPart> = {
    AnyIdentifier => Box::new(PatternPart::Keyword(<>)),
    "{" <name_value: NameValuePair> "}" => Box::new(PatternPart::Parameter { key: name_value.0, internal_name: name_value.1 }),
}

Function: Box<Function> = {
    <decorators: Decorator*> "def" <target_type: (<ContextualParameter> ".")?> <identifier: Identifier> "(" <parameters: OptionalFinalSeparatorList<KeyedParameter, ",">> ")" <return_type: ("->" <Expression>)?> <body: ("::" <FunctionBody>)?> => Box::new(Function { <> }),
}

OperatorFunction: Box<OperatorFunction> = {
    <decorators: Decorator*> "def" <parts: OperatorArgument+> <return_type: ("->" <Expression>)?> <body: ("::" <FunctionBody>)?> => Box::new(OperatorFunction { <> }),
}

GlobalMacro: Box<GlobalMacro> = {
    <decorators: Decorator*> "def" "@" <macro_name: Identifier> <body: ("::" <FunctionBody>)?> => Box::new(GlobalMacro { <> }),
}

Decorator: String = {
    "@" <Identifier>
}

OperatorArgument: Box<OperatorArgument> = {
    AnyIdentifier => Box::new(OperatorArgument::Keyword(<>)),
    ContextualParameter => Box::new(OperatorArgument::Parameter(<>)),
}

ContextualParameter: Box<Expression> = {
    "{" <param_type: Expression> "}" => Box::new(param_type),
}

FunctionBody: Expression = {
    <Expression>,
}

KeyedParameter: Box<KeyedParameter> = {
    <name_value: NameValuePair> "'" <param_type: Expression> => Box::new(KeyedParameter {
        key: name_value.0, internal_name: name_value.1, param_type
    }),
}

NameValuePair: (ParameterKey, String) = {
    <name: Identifier> ":" <value: Identifier> => (ParameterKey::Name(name), value),
    <name: Identifier> ":" => (ParameterKey::Name(name.clone()), name),
    <value: Identifier> => (ParameterKey::Positional, value),
}

// =============================== Trait =====================================

Trait: Box<TraitDefinition> = {
    <decorators: Decorator*> "trait" <name: Identifier> "{" <statements: (<GlobalStatement> ";")*> "}" => Box::new(TraitDefinition { <> }),
}

Conformance: Box<TraitConformanceDeclaration> = {
    "declare" <declared_for: Expression> "is" <declared: Identifier> "{" <statements: (<GlobalStatement> ";")*> "}" => Box::new(TraitConformanceDeclaration { <> }),
}

// =============================== Statement =====================================


pub Statement: Box<Statement> = {
    <mutability: VariableDeclarationMutability> <identifier: Identifier> <type_declaration: ("'" <Expression>)?> "=" <expression: Expression> => Box::new(Statement::VariableDeclaration { mutability, identifier, type_declaration, expression }),
    "upd" <variable_name: Identifier> "=" <new_value: Expression> => Box::new(Statement::VariableAssignment { variable_name, new_value }),
    "return" <Expression?> => Box::new(Statement::Return(<>)),
    Expression => Box::new(Statement::Expression(<>)),
    <start:@L> <e: !> <end:@R> => { errors.push(e.clone()); Box::new(Statement::Error(derive_error(&e, start, end))) },
};

VariableDeclarationMutability: Mutability = {
    "let" => Mutability::Immutable,
    "var" => Mutability::Mutable,
};

// =============================== Expression =====================================

Expression: Expression = {
    Term+ => Expression::from(<>)
};

Term: Box<Term> = {
    AnyIdentifier => Box::new(Term::Identifier(<>)),
    IntLiteral => Box::new(Term::IntLiteral(<>)),
    RealLiteral => Box::new(Term::RealLiteral(<>)),
    "[" <OptionalFinalSeparatorList<ArrayArgument, ",">> "]" => Box::new(Term::Array(<>)),
    "(" <OptionalFinalSeparatorList<StructArgument, ",">> ")" => Box::new(Term::Struct(<>)),
    <target: Term> "." <member_name: Identifier> => Box::new(Term::MemberAccess { <> }),
    "\"" <StringPart*> "\"" => Box::new(Term::StringLiteral(<>)),
    "{" <(<Statement> ";")*> "}" => Box::new(Term::Block(<>)),
};

StructArgument: StructArgument = {
    <key: Identifier> ":" <value: Expression> <type_declaration: ("'" <Expression>)?> => StructArgument { key: ParameterKey::Name(key), value, type_declaration },
    <value: Expression> <type_declaration: ("'" <Expression>)?> => StructArgument { key: ParameterKey::Positional, value, type_declaration },
    <key: Identifier> ":" => StructArgument { key: ParameterKey::Name(key.clone()), value: Expression::from(vec![Box::new(Term::Identifier(key))]), type_declaration: None },  // TODO Maybe better handled post-syntax?
}

ArrayArgument: ArrayArgument = {
    <key: Expression> ":" <value: Expression> <type_declaration: ("'" <Expression>)?> => ArrayArgument { key: Some(key), value, type_declaration },
    <value: Expression> <type_declaration: ("'" <Expression>)?>=> ArrayArgument { key: None, value, type_declaration },
}

StringPart: StringPart = {
    StringLiteral => StringPart::Literal(<>.to_string()),
    "(" <OptionalFinalSeparatorList<StructArgument, ",">> ")" => StringPart::Object(<>),
}

// =============================== Util =====================================

OptionalFinalSeparatorList<Element, Separator>: Vec<Element> = {
    <v0: (<Element> Separator)*> <e1: Element?> => v0.into_iter().chain(e1).collect()
};
