use lalrpop_util::ErrorRecovery;
use std::str::FromStr;
use itertools::Itertools;
use crate::util::position::*;
use crate::parser::ast::*;
use crate::parser::lexer::*;
use crate::parser::error::*;
use crate::program::types::*;
use crate::program::allocation::*;
use crate::program::functions::ParameterKey;

grammar<'i, 'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'i>, Error>>, text: &'i str);

extern {
    type Location = usize;
    type Error = Error;

    enum Token<'i> {
        _Identifier => Token::Identifier(_),
        _MacroIdentifier => Token::MacroIdentifier(_),
        _OperatorIdentifier => Token::OperatorIdentifier(_),
        _IntLiteral => Token::IntLiteral(_),
        _RealLiteral => Token::RealLiteral(_),
        StringLiteral => Token::StringLiteral(_),

        "def" => Token::Symbol("def"),
        "trait" => Token::Symbol("trait"),
        "declare" => Token::Symbol("declare"),

        "!" => Token::Symbol("!"),
        "{" => Token::Symbol("{"),
        "}" => Token::Symbol("}"),
        "(" => Token::Symbol("("),
        ")" => Token::Symbol(")"),
        "[" => Token::Symbol("["),
        "]" => Token::Symbol("]"),
        "::" => Token::Symbol("::"),
        ":" => Token::Symbol(":"),
        "@" => Token::Symbol("@"),
        "'" => Token::Symbol("'"),
        "=" => Token::Symbol("="),
        "," => Token::Symbol(","),
        ";" => Token::Symbol(";"),
        "." => Token::Symbol("."),
        "->" => Token::Symbol("->"),
        "\"" => Token::Symbol("\""),

        "let" => Token::Symbol("let"),
        "var" => Token::Symbol("var"),
        "upd" => Token::Symbol("upd"),
        "return" => Token::Symbol("return"),

        "is" => Token::Symbol("is"),
    }
}

// =============================== Primitive =====================================

Identifier: String = { _Identifier => <>.to_string() };
MacroIdentifier: String = { _MacroIdentifier => <>.to_string() };
OperatorIdentifier: String = { _OperatorIdentifier => <>.to_string(), };
IntLiteral: String = { _IntLiteral => <>.to_string() };
RealLiteral: String = { _RealLiteral => <>.to_string() };

AnyIdentifier: String = {
    Identifier,
    OperatorIdentifier,
};


// =============================== Global =====================================


pub Program: Module = {
    <global_statements: Box<Decorated<Positioned<(<Statement> ";")>>>*> => Module { <> }
};

Function: Box<Function> = {
    "def" <interface: FunctionInterface> <body: ("::" <FunctionBody>)?> => Box::new(Function { <> }),
}

FunctionInterface: FunctionInterface = {
    <expression: Expression> <return_type: ("->" <Expression>)?> => FunctionInterface { <> },
}

FunctionBody: Expression = {
    <Expression>,
}

// =============================== Trait =====================================

Trait: Box<TraitDefinition> = {
    "trait" <name: Identifier> "{" <statements: (<Box<Positioned<Statement>>> ";")*> "}" => Box::new(TraitDefinition { <> }),
}

Conformance: Box<TraitConformanceDeclaration> = {
    "declare" <declared_for: Expression> "is" <declared: Identifier> "{" <statements: (<Box<Positioned<Statement>>> ";")*> "}" => Box::new(TraitConformanceDeclaration { <> }),
}

// =============================== Statement =====================================


Statement: Statement = {
    <mutability: VariableDeclarationMutability> <identifier: Identifier> <type_declaration: ("'" <Expression>)?> <assignment: ("=" <Expression>)?> => Statement::VariableDeclaration { mutability, identifier, type_declaration, assignment },
    "upd" <target: Expression> "=" <new_value: Expression> => Statement::VariableUpdate { <> },
    "return" <Expression?> => Statement::Return(<>),
    Expression => Statement::Expression(<>),
    Function => Statement::FunctionDeclaration(<>),
    Trait => Statement::Trait(<>),
    Conformance => Statement::Conformance(<>),
}

VariableDeclarationMutability: Mutability = {
    "let" => Mutability::Immutable,
    "var" => Mutability::Mutable,
}

// =============================== Expression =====================================

Expression: Expression = {
    Box<Positioned<Term>>+ => Expression::from(<>),
}

Term: Term = {
    AnyIdentifier => Term::Identifier(<>),
    MacroIdentifier => Term::MacroIdentifier(<>),
    IntLiteral => Term::IntLiteral(<>),
    RealLiteral => Term::RealLiteral(<>),
    "." => Term::Dot,
    "[" <OptionalFinalSeparatorList<ArrayArgument, ",">> "]" => Term::Array(<>),
    "(" <OptionalFinalSeparatorList<StructArgument, ",">> ")" => Term::Struct(<>),
    "\"" <Box<Positioned<StringPart>>*> "\"" => Term::StringLiteral(<>),
    "{" <(<Box<Positioned<Statement>>> ";")*> "}" => Term::Block(<>),
    <start:@L> <e: !> <end:@R> => { errors.push(e.clone()); Term::Error(derive_error(&e, start, end)) },
}

StructArgument: StructArgument = {
    <key: Identifier> ":" <value: Expression> <type_declaration: ("'" <Expression>)?> => StructArgument { key: ParameterKey::Name(key), value: value, type_declaration },
    <value: Expression> <type_declaration: ("'" <Expression>)?> => StructArgument { key: ParameterKey::Positional, value: value, type_declaration },
    <start:@L> <key: Identifier> <end:@R> ":" <type_declaration: ("'" <Expression>)?> => StructArgument { key: ParameterKey::Name(key.clone()), value: Expression::from(vec![Box::new(positioned(Term::Identifier(key.clone()), start, end))]), type_declaration: type_declaration },
}

ArrayArgument: ArrayArgument = {
    <key: Expression> ":" <value: Expression> <type_declaration: ("'" <Expression>)?> => ArrayArgument { key: Some(key), value, type_declaration },
    <value: Expression> <type_declaration: ("'" <Expression>)?>=> ArrayArgument { key: None, value, type_declaration },
}

StringPart: StringPart = {
    StringLiteral => StringPart::Literal(<>.to_string()),
    "(" <OptionalFinalSeparatorList<StructArgument, ",">> ")" => StringPart::Object(<>),
}

// =============================== Util =====================================

Box<Element>: Box<Element> = {
    Element => Box::new(<>),
}

Positioned<Element>: Positioned<Element> = {
    <start: @L> <v: Element> <end: @R> => positioned(v, start, end),
}

Decorated<Element>: Decorated<Element> = {
    <decorations: ("!" "[" <OptionalFinalSeparatorList<ArrayArgument, ",">> "]")?> <value: Element> => Decorated { decorations: decorations.unwrap_or(vec![]), value },
}

OptionalFinalSeparatorList<Element, Separator>: Vec<Element> = {
    <v0: (<Element> Separator)*> <e1: Element?> => v0.into_iter().chain(e1).collect()
}
