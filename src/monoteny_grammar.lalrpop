use lalrpop_util::ErrorRecovery;
use std::str::FromStr;
use itertools::Itertools;
use crate::util::position::*;
use crate::parser::ast::*;
use crate::parser::lexer::*;
use crate::parser::error::*;
use crate::program::types::*;
use crate::program::allocation::*;
use crate::program::functions::ParameterKey;

grammar<'i, 'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'i>, Error>>, text: &'i str);

extern {
    type Location = usize;
    type Error = Error;

    enum Token<'i> {
        _Identifier => Token::Identifier(_),
        _OperatorIdentifier => Token::OperatorIdentifier(_),
        _IntLiteral => Token::IntLiteral(_),
        _RealLiteral => Token::RealLiteral(_),
        StringLiteral => Token::StringLiteral(_),

        "def" => Token::Symbol("def"),
        "pattern" => Token::Symbol("pattern"),
        "trait" => Token::Symbol("trait"),
        "declare" => Token::Symbol("declare"),

        "{" => Token::Symbol("{"),
        "}" => Token::Symbol("}"),
        "(" => Token::Symbol("("),
        ")" => Token::Symbol(")"),
        "[" => Token::Symbol("["),
        "]" => Token::Symbol("]"),
        "::" => Token::Symbol("::"),
        ":" => Token::Symbol(":"),
        "@" => Token::Symbol("@"),
        "'" => Token::Symbol("'"),
        "=" => Token::Symbol("="),
        "," => Token::Symbol(","),
        ";" => Token::Symbol(";"),
        "." => Token::Symbol("."),
        "->" => Token::Symbol("->"),
        "\"" => Token::Symbol("\""),

        "let" => Token::Symbol("let"),
        "var" => Token::Symbol("var"),
        "upd" => Token::Symbol("upd"),
        "return" => Token::Symbol("return"),

        "is" => Token::Symbol("is"),
    }
}

// =============================== Primitive =====================================

Identifier: String = { _Identifier => <>.to_string() };
OperatorIdentifier: String = { _OperatorIdentifier => <>.to_string(), };
IntLiteral: String = { _IntLiteral => <>.to_string() };
RealLiteral: String = { _RealLiteral => <>.to_string() };

AnyIdentifier: String = {
    Identifier,
    OperatorIdentifier,
};


// =============================== Global =====================================


pub Program: Module = {
    <global_statements: Box<Positioned<(<Statement> ";")>>*> => Module { <> }
};

Pattern: Box<PatternDeclaration> = {
    "pattern" <alias: Identifier> "(" <precedence: Identifier> ")" "::" <parts: PatternPart+> => Box::new(PatternDeclaration { <> }),
}

PatternPart: Box<PatternPart> = {
    AnyIdentifier => Box::new(PatternPart::Keyword(<>)),
    "{" <name_value: NameValuePair> "}" => Box::new(PatternPart::Parameter { key: name_value.0, internal_name: name_value.1 }),
}

Function: Box<Function> = {
    <decorators: Decorator*> "def" <target_type: (<ContextualParameter> ".")?> <identifier: Identifier> "(" <parameters: OptionalFinalSeparatorList<KeyedParameter, ",">> ")" <return_type: ("->" <Expression>)?> <body: ("::" <FunctionBody>)?> => Box::new(Function { <> }),
}

OperatorFunction: Box<OperatorFunction> = {
    <decorators: Decorator*> "def" <parts: OperatorArgument+> <return_type: ("->" <Expression>)?> <body: ("::" <FunctionBody>)?> => Box::new(OperatorFunction { <> }),
}

GlobalMacro: Box<GlobalMacro> = {
    <decorators: Decorator*> "def" "@" <macro_name: Identifier> <body: ("::" <FunctionBody>)?> => Box::new(GlobalMacro { <> }),
}

Decorator: String = {
    "@" <Identifier>
}

OperatorArgument: Box<OperatorArgument> = {
    AnyIdentifier => Box::new(OperatorArgument::Keyword(<>)),
    ContextualParameter => Box::new(OperatorArgument::Parameter(<>)),
}

ContextualParameter: Box<Expression> = {
    "{" <param_type: Expression> "}" => Box::new(param_type),
}

FunctionBody: Expression = {
    <Expression>,
}

KeyedParameter: Box<KeyedParameter> = {
    <name_value: NameValuePair> "'" <param_type: Expression> => Box::new(KeyedParameter {
        key: name_value.0, internal_name: name_value.1, param_type
    }),
}

NameValuePair: (ParameterKey, String) = {
    <name: Identifier> ":" <value: Identifier> => (ParameterKey::Name(name), value),
    <name: Identifier> ":" => (ParameterKey::Name(name.clone()), name),
    <value: Identifier> => (ParameterKey::Positional, value),
}

// =============================== Trait =====================================

Trait: Box<TraitDefinition> = {
    <decorators: Decorator*> "trait" <name: Identifier> "{" <statements: (<Box<Positioned<Statement>>> ";")*> "}" => Box::new(TraitDefinition { <> }),
}

Conformance: Box<TraitConformanceDeclaration> = {
    "declare" <declared_for: Expression> "is" <declared: Identifier> "{" <statements: (<Box<Positioned<Statement>>> ";")*> "}" => Box::new(TraitConformanceDeclaration { <> }),
}

// =============================== Statement =====================================


pub Statement: Statement = {
    <mutability: VariableDeclarationMutability> <identifier: Identifier> <type_declaration: ("'" <Expression>)?> <assignment: ("=" <Expression>)?> => Statement::VariableDeclaration { mutability, identifier, type_declaration, assignment },
    "upd" <variable_name: Identifier> "=" <new_value: Expression> => Statement::VariableAssignment { variable_name, new_value },
    "return" <Expression?> => Statement::Return(<>),
    Expression => Statement::Expression(<>),
    Function => Statement::FunctionDeclaration(<>),
    Pattern => Statement::Pattern(<>),
    OperatorFunction => Statement::Operator(<>),
    Trait => Statement::Trait(<>),
    Conformance => Statement::Conformance(<>),
    GlobalMacro => Statement::Macro(<>),
};

VariableDeclarationMutability: Mutability = {
    "let" => Mutability::Immutable,
    "var" => Mutability::Mutable,
};

// =============================== Expression =====================================

Expression: Expression = {
    Box<Positioned<Term>>+ => Expression::from(<>),
};

Term: Term = {
    AnyIdentifier => Term::Identifier(<>),
    IntLiteral => Term::IntLiteral(<>),
    RealLiteral => Term::RealLiteral(<>),
    "[" <OptionalFinalSeparatorList<ArrayArgument, ",">> "]" => Term::Array(<>),
    "(" <OptionalFinalSeparatorList<StructArgument, ",">> ")" => Term::Struct(<>),
    <target: Box<Positioned<Term>>> "." <member_name: Identifier> => Term::MemberAccess { <> },
    "\"" <Box<Positioned<StringPart>>*> "\"" => Term::StringLiteral(<>),
    "{" <(<Box<Positioned<Statement>>> ";")*> "}" => Term::Block(<>),
    <start:@L> <e: !> <end:@R> => { errors.push(e.clone()); Term::Error(derive_error(&e, start, end)) },
};

StructArgument: StructArgument = {
    <key: Identifier> ":" <value: Expression> <type_declaration: ("'" <Expression>)?> => StructArgument { key: ParameterKey::Name(key), value: value, type_declaration },
    <value: Expression> <type_declaration: ("'" <Expression>)?> => StructArgument { key: ParameterKey::Positional, value: value, type_declaration },
    <start:@L> <key: Identifier> <end:@R> ":" => StructArgument { key: ParameterKey::Name(key.clone()), value: Expression::from(vec![Box::new(positioned(Term::Identifier(key.clone()), start, end))]), type_declaration: None },
}

ArrayArgument: ArrayArgument = {
    <key: Expression> ":" <value: Expression> <type_declaration: ("'" <Expression>)?> => ArrayArgument { key: Some(key), value, type_declaration },
    <value: Expression> <type_declaration: ("'" <Expression>)?>=> ArrayArgument { key: None, value, type_declaration },
}

StringPart: StringPart = {
    StringLiteral => StringPart::Literal(<>.to_string()),
    "(" <OptionalFinalSeparatorList<StructArgument, ",">> ")" => StringPart::Object(<>),
}

// =============================== Util =====================================

Box<Element>: Box<Element> = {
    Element => Box::new(<>),
}

Positioned<Element>: Positioned<Element> = {
    <start: @L> <v: Element> <end: @R> => positioned(v, start, end),
}

OptionalFinalSeparatorList<Element, Separator>: Vec<Element> = {
    <v0: (<Element> Separator)*> <e1: Element?> => v0.into_iter().chain(e1).collect()
};
