use std::str::FromStr;
use crate::ast::{Program, Expression, Opcode, Statement, GlobalStatement, Mutability, ParameterDeclaration, TypeDeclaration, PassedArgument};

grammar;

OptionalFinalSeparatorList<E,S>: Vec<E> =
    <v0:(<E> S)*> <e1:E?> =>
        v0.into_iter().chain(e1).collect();

match {
    r"[0-9]+" => _Number,
    "return",
    "(", ")", "{", "}", "[",  "]",
    ";", ",", ":",
    "=",
    "+", "-", "*", "/",
    "let", "var",
    "fn",
} else {
    r"[a-zA-Z_]\w*" => _Identifier,
    _
}

pub Program: Program = {
    <stmts: (<GlobalStatement>)*> => Program { global_statements: stmts }
};

pub GlobalStatement: Box<GlobalStatement> = {
    FunctionDeclaration,
};

FunctionDeclaration: Box<GlobalStatement> = {
    "fn" <i: Identifier> "(" <parameters: OptionalFinalSeparatorList<ParameterDeclaration, ",">> ")" "{" <stmnts: (<Statement> ";")*> "}" => Box::new(GlobalStatement::FunctionDeclaration(i, parameters, stmnts)),
};

ParameterDeclaration: Box<ParameterDeclaration> = {
    <name: Identifier> ":" <param_type: TypeDeclaration> => Box::new(ParameterDeclaration {
        internal_name: name.clone(), external_name: name.clone(), param_type
  })
}

TypeDeclaration: Box<TypeDeclaration> = {
    Identifier => Box::new(TypeDeclaration::Identifier(<>))
}

pub Statement: Box<Statement> = {
    <m: VariableDeclarationMutability> <i: Identifier> "=" <e: Expression> => Box::new(Statement::VariableDeclaration(m, i, Box::new(None), e)),
    "return" <Expression> => Box::new(Statement::Return(<>)),
    Expression => Box::new(Statement::Expression(<>)),
};

BinaryOperator<Operator, NextOperatorLevel>: Box<Expression> = {
    BinaryOperator<Operator, NextOperatorLevel> Operator NextOperatorLevel => Box::new(Expression::BinaryOperator(<>)),
    NextOperatorLevel
};

Expression: Box<Expression> = FunctionCallElement;

FunctionCallElement = {
    <Expression> "(" <PassedArgument*> ")" => Box::new(Expression::FunctionCall(<>)),
    <Expression> "." <Identifier> => Box::new(Expression::MemberLookup(<>)),
    SumElement
}
SumElement = BinaryOperator<SumOperator, MultiplicationElement>;
MultiplicationElement = BinaryOperator<FactorOperator, Term>;

PassedArgument: Box<PassedArgument> = {
    <name: Identifier> ":" <value: Expression> => Box::new(PassedArgument { name, value })
}

SumOperator: Opcode = { // (3)
    "+" => Opcode::Add,
    "-" => Opcode::Subtract,
};

FactorOperator: Opcode = {
    "*" => Opcode::Multiply,
    "/" => Opcode::Divide,
};

VariableDeclarationMutability: Mutability = {
    "let" => Mutability::Immutable,
    "var" => Mutability::Mutable,
};

Term: Box<Expression> = {
    Num => Box::new(Expression::Number(<>)),
    Identifier => Box::new(Expression::VariableLookup(<>)),
    "(" <Expression> ")",
    "[" <OptionalFinalSeparatorList<Expression, ",">> "]" => Box::new(Expression::ArrayLiteral(<>)),
};

Num: i32 = {
    _Number => i32::from_str(<>).unwrap()
};

Identifier: String = {
    _Identifier => format!("{}", <>)
};
