use std::str::FromStr;
use crate::abstract_syntax::*;

grammar;

// =============================== Lexer Precedence =====================================

match {
    r"[0-9]+" => _Number,
    "true", "false",
    "return",
    "(", ")", "{", "}", "[",  "]",
    ";", ",", ":",
    "=", "?",
    "!",
    "+", "-", "*", "/", "&&", "||",
    "**", "%",
    "==", "!=", ">", ">=", "<", "<=",
    "let", "var",
    "fun",
     "extension",
} else {
    r"[a-zA-Z_]\w*" => _Identifier,
    _
}

// =============================== Primitive =====================================

Number: i32 = {
    _Number => i32::from_str(<>).unwrap()
};

BoolLiteral: bool = {
    "true" => true,
    "false" => false,
};

Identifier: String = {
    _Identifier => format!("{}", <>)
};

// =============================== Global =====================================


pub Program: Program = {
    <stmts: (<GlobalStatement>)*> => Program { global_statements: stmts }
};

pub GlobalStatement: Box<GlobalStatement> = {
    Function => Box::new(GlobalStatement::FunctionDeclaration(<>)),
    Extension => Box::new(GlobalStatement::Extension(<>))
};

Function: Box<Function> = {
    "fun" <identifier: Identifier> "(" <parameters: OptionalFinalSeparatorList<Parameter, ",">> ")" <return_type: (":" <TypeDeclaration>)?> "::" "{" <body: (<Statement> ";")*> "}" => Box::new(Function {
        identifier, parameters, return_type, body
    }),
}

Parameter: Box<Parameter> = {
    <internal_name: Identifier> ":" <param_type: TypeDeclaration> => Box::new(Parameter {
        key: ParameterKey::Name(internal_name.clone()), internal_name, param_type
    }),
    <key: Number> <internal_name: Identifier> ":" <param_type: TypeDeclaration> => Box::new(Parameter {
        key: ParameterKey::Int(key), internal_name, param_type
    }),
    <key: Identifier> <internal_name: Identifier> ":" <param_type: TypeDeclaration> => Box::new(Parameter {
        key: ParameterKey::Name(key), internal_name, param_type
    }),
}

// =============================== Member =====================================

pub Extension: Box<Extension> = {
    "extension" <type_declaration: TypeDeclaration> "{" <statements: (<MemberStatement>)*> "}" => Box::new(Extension {
        type_declaration, statements
    })
};

pub MemberStatement: Box<MemberStatement> = {
    Function => Box::new(MemberStatement::FunctionDeclaration(<>)),
};

// =============================== Type =====================================


TypeDeclaration: Box<TypeDeclaration> = {
    Identifier => Box::new(TypeDeclaration::Identifier(<>)),
    <TypeDeclaration> "[" <OptionalFinalSeparatorList<Expression, ",">> "]" => Box::new(TypeDeclaration::NDArray(<>))
}


// =============================== Statement =====================================


pub Statement: Box<Statement> = {
    <mutability: VariableDeclarationMutability> <identifier: Identifier> ":" <type_declaration: TypeDeclaration> "=" <expression: Expression> => Box::new(Statement::VariableDeclaration { mutability, identifier, type_declaration: Some(type_declaration), expression }),
    <mutability: VariableDeclarationMutability> <identifier: Identifier> "=" <expression: Expression> => Box::new(Statement::VariableDeclaration { mutability, identifier, type_declaration: None, expression }),
    <i: Identifier> "=" <e: Expression> => Box::new(Statement::VariableAssignment(i, e)),
    "return" <Expression> => Box::new(Statement::Return(Some(<>))),
    "return" => Box::new(Statement::Return(None)),
    Expression => Box::new(Statement::Expression(<>)),
};

VariableDeclarationMutability: Mutability = {
    "let" => Mutability::Immutable,
    "var" => Mutability::Mutable,
};

// =============================== Expression =====================================

Expression: Box<Expression> = FunctionCallPrecedenceGroup;
FunctionCallPrecedenceGroup = FunctionCallExpression<LogicalPrecedenceGroup>;
LogicalPrecedenceGroup = LeftAssociativeBinaryOperator<LogicalOperator, ComparisonPrecedenceGroup>;
ComparisonPrecedenceGroup = ComparisonExpression<AdditionPrecedenceGroup>;
AdditionPrecedenceGroup = LeftAssociativeBinaryOperator<SumOperator, MultiplicationPrecedenceGroup>;
MultiplicationPrecedenceGroup = LeftAssociativeBinaryOperator<FactorOperator, ExponentiationPrecedenceGroup>;
ExponentiationPrecedenceGroup = RightAssociativeBinaryOperator<ExponentiationOperator, Term>;

Term: Box<Expression> = {
    Number => Box::new(Expression::Number(<>)),
    BoolLiteral => Box::new(Expression::Bool(<>)),
    Identifier => Box::new(Expression::VariableLookup(<>)),
    "(" <Expression> ")",
    "[" <OptionalFinalSeparatorList<Expression, ",">> "]" => Box::new(Expression::ArrayLiteral(<>)),
    r"\x22[^\x22]*\x22" => {
        let s = <>;
        Box::new(Expression::StringLiteral(String::from(&s[1..(s.len() - 1)])))
    }
};

PassedArgument: Box<PassedArgument> = {
    <name: Number> ":" <value: Expression> => Box::new(PassedArgument { key: Some(ParameterKey::Int(name)), value }),
    <name: Identifier> ":" <value: Expression> => Box::new(PassedArgument { key: Some(ParameterKey::Name(name)), value }),
    <value: Expression> => Box::new(PassedArgument { key: None, value })
}

ExponentiationOperator: BinaryOperator = {
    "**" => BinaryOperator::Exponentiate,
};

LogicalOperator: BinaryOperator = {
    "||" => BinaryOperator::Or,
    "&&" => BinaryOperator::And,
};

SumOperator: BinaryOperator = {
    "+" => BinaryOperator::Add,
    "-" => BinaryOperator::Subtract,
};

FactorOperator: BinaryOperator = {
    "*" => BinaryOperator::Multiply,
    "/" => BinaryOperator::Divide,
    "%" => BinaryOperator::Modulo,
};

UnaryOperator: UnaryOperator = {
    "!" => UnaryOperator::Not,
};

FunctionCallExpression<NextOperatorLevel>: Box<Expression> = {
    <Expression> "(" <OptionalFinalSeparatorList<PassedArgument, ",">> ")" => Box::new(Expression::FunctionCall(FunctionCallType::Call, <>)),
    <Expression> "[" <OptionalFinalSeparatorList<PassedArgument, ",">> "]" => Box::new(Expression::FunctionCall(FunctionCallType::Subscript, <>)),
    <Expression> "." <Identifier> => Box::new(Expression::MemberLookup(<>)),
    NextOperatorLevel
}

ComparisonExpression<NextOperatorLevel>: Box<Expression> = {
    AtLeastTwoElementsSeparatorList<NextOperatorLevel, "=="> => Box::new(Expression::NAryOperator(NAryOperator::EqualTo, <>)),
    AtLeastTwoElementsSeparatorList<NextOperatorLevel, "!="> => Box::new(Expression::NAryOperator(NAryOperator::NotEqualTo, <>)),

    AtLeastTwoElementsSeparatorList<NextOperatorLevel, ">"> => Box::new(Expression::NAryOperator(NAryOperator::GreaterThan, <>)),
    AtLeastTwoElementsSeparatorList<NextOperatorLevel, ">="> => Box::new(Expression::NAryOperator(NAryOperator::GreaterThanOrEqualTo, <>)),
    AtLeastTwoElementsSeparatorList<NextOperatorLevel, "<"> => Box::new(Expression::NAryOperator(NAryOperator::LesserThan, <>)),
    AtLeastTwoElementsSeparatorList<NextOperatorLevel, "<="> => Box::new(Expression::NAryOperator(NAryOperator::LesserThanOrEqualTo, <>)),

    NextOperatorLevel,
}


// =============================== Util =====================================

OptionalFinalSeparatorList<Element, Separator>: Vec<Element> = {
    <v0: (<Element> Separator)*> <e1: Element?> => v0.into_iter().chain(e1).collect()
};

AtLeastTwoElementsSeparatorList<Element, Separator>: Vec<Element> = {
    <v0: (<Element> Separator)+> <e1: Element> => v0.into_iter().chain([e1]).collect()
};

LeftAssociativeBinaryOperator<Operator, NextOperatorLevel>: Box<Expression> = {
    LeftAssociativeBinaryOperator<Operator, NextOperatorLevel> Operator NextOperatorLevel => Box::new(Expression::BinaryOperator(<>)),
    NextOperatorLevel
};

RightAssociativeBinaryOperator<Operator, NextOperatorLevel>: Box<Expression> = {
    NextOperatorLevel Operator RightAssociativeBinaryOperator<Operator, NextOperatorLevel> => Box::new(Expression::BinaryOperator(<>)),
    NextOperatorLevel
};
