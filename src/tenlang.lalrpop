use std::str::FromStr;
use crate::abstract_syntax::*;

grammar;

// =============================== Util =====================================

OptionalFinalSeparatorList<Element, Separator>: Vec<Element> = {
    <v0: (<Element> Separator)*> <e1: Element?> => v0.into_iter().chain(e1).collect()
};

UnassociativeBinaryOperator<Operator, NextOperatorLevel>: Box<Expression> = {
    NextOperatorLevel Operator NextOperatorLevel => Box::new(Expression::BinaryOperator(<>)),
    NextOperatorLevel
};

LeftAssociativeBinaryOperator<Operator, NextOperatorLevel>: Box<Expression> = {
    LeftAssociativeBinaryOperator<Operator, NextOperatorLevel> Operator NextOperatorLevel => Box::new(Expression::BinaryOperator(<>)),
    NextOperatorLevel
};

RightAssociativeBinaryOperator<Operator, NextOperatorLevel>: Box<Expression> = {
    NextOperatorLevel Operator RightAssociativeBinaryOperator<Operator, NextOperatorLevel> => Box::new(Expression::BinaryOperator(<>)),
    NextOperatorLevel
};

match {
    r"[0-9]+" => _Number,
    "true", "false",
    "return",
    "(", ")", "{", "}", "[",  "]",
    ";", ",", ":",
    "=", "?",
    "!",
    "+", "-", "*", "/", "&&", "||",
    "**", "%",
    "==", "!=", ">", ">=", "<", "<=",
    "let", "var",
    "fn", "extension",
} else {
    r"[a-zA-Z_]\w*" => _Identifier,
    _
}


// =============================== Global =====================================


pub Program: Program = {
    <stmts: (<GlobalStatement>)*> => Program { global_statements: stmts }
};

pub GlobalStatement: Box<GlobalStatement> = {
    Function => Box::new(GlobalStatement::FunctionDeclaration(<>)),
    Extension => Box::new(GlobalStatement::Extension(<>))
};

Function: Box<Function> = {
    "fn" <identifier: Identifier> "(" <parameters: OptionalFinalSeparatorList<Parameter, ",">> ")" <return_type: ("->" <TypeDeclaration>)?> "{" <body: (<Statement> ";")*> "}" => Box::new(Function {
        identifier, parameters, return_type, body
    }),
}

Parameter: Box<Parameter> = {
    <internal_name: Identifier> ":" <param_type: TypeDeclaration> => Box::new(Parameter {
        key: ParameterKey::Name(internal_name.clone()), internal_name, param_type
    }),
    <key: Number> <internal_name: Identifier> ":" <param_type: TypeDeclaration> => Box::new(Parameter {
        key: ParameterKey::Int(key), internal_name, param_type
    }),
    <key: Identifier> <internal_name: Identifier> ":" <param_type: TypeDeclaration> => Box::new(Parameter {
        key: ParameterKey::Name(key), internal_name, param_type
    }),
}

// =============================== Member =====================================

pub Extension: Box<Extension> = {
    "extension" <type_declaration: TypeDeclaration> "{" <statements: (<MemberStatement>)*> "}" => Box::new(Extension {
        type_declaration, statements
    })
};

pub MemberStatement: Box<MemberStatement> = {
    Function => Box::new(MemberStatement::FunctionDeclaration(<>)),
};

// =============================== Type =====================================


TypeDeclaration: Box<TypeDeclaration> = {
    Identifier => Box::new(TypeDeclaration::Identifier(<>)),
    <TypeDeclaration> "[" <OptionalFinalSeparatorList<Expression, ",">> "]" => Box::new(TypeDeclaration::NDArray(<>))
}


// =============================== Code =====================================


pub Statement: Box<Statement> = {
    <mutability: VariableDeclarationMutability> <identifier: Identifier> ":" <type_declaration: TypeDeclaration> "=" <expression: Expression> => Box::new(Statement::VariableDeclaration { mutability, identifier, type_declaration: Some(type_declaration), expression }),
    <mutability: VariableDeclarationMutability> <identifier: Identifier> "=" <expression: Expression> => Box::new(Statement::VariableDeclaration { mutability, identifier, type_declaration: None, expression }),
    <i: Identifier> "=" <e: Expression> => Box::new(Statement::VariableAssignment(i, e)),
    "return" <Expression> => Box::new(Statement::Return(Some(<>))),
    "return" => Box::new(Statement::Return(None)),
    Expression => Box::new(Statement::Expression(<>)),
};

VariableDeclarationMutability: Mutability = {
    "let" => Mutability::Immutable,
    "var" => Mutability::Mutable,
};

Expression: Box<Expression> = FunctionCallElement;

FunctionCallElement = {
    <Expression> "(" <OptionalFinalSeparatorList<PassedArgument, ",">> ")" => Box::new(Expression::FunctionCall(FunctionCallType::Call, <>)),
    <Expression> "[" <OptionalFinalSeparatorList<PassedArgument, ",">> "]" => Box::new(Expression::FunctionCall(FunctionCallType::Subscript, <>)),
    <Expression> "." <Identifier> => Box::new(Expression::MemberLookup(<>)),
    LogicalElement
}

LogicalElement = LeftAssociativeBinaryOperator<LogicalOperator, ComparisonElement>;
ComparisonElement = UnassociativeBinaryOperator<ComparisonOperator, SumElement>;
SumElement = LeftAssociativeBinaryOperator<SumOperator, MultiplicationElement>;
MultiplicationElement = LeftAssociativeBinaryOperator<FactorOperator, PowerElement>;
PowerElement = LeftAssociativeBinaryOperator<PowerOperator, Term>;

PassedArgument: Box<PassedArgument> = {
    <name: Number> ":" <value: Expression> => Box::new(PassedArgument { key: Some(ParameterKey::Int(name)), value }),
    <name: Identifier> ":" <value: Expression> => Box::new(PassedArgument { key: Some(ParameterKey::Name(name)), value }),
    <value: Expression> => Box::new(PassedArgument { key: None, value })
}

PowerOperator: BinaryOperator = {
    "**" => BinaryOperator::ToThePowerOf,
};

LogicalOperator: BinaryOperator = {
    "||" => BinaryOperator::Or,
    "&&" => BinaryOperator::And,
};

ComparisonOperator: BinaryOperator = {
    "==" => BinaryOperator::EqualTo,
    "!=" => BinaryOperator::NotEqualTo,

    ">" => BinaryOperator::GreaterThan,
    ">=" => BinaryOperator::GreaterThanOrEqualTo,
    "<" => BinaryOperator::LesserThan,
    "<=" => BinaryOperator::LesserThanOrEqualTo,
};

SumOperator: BinaryOperator = {
    "+" => BinaryOperator::Add,
    "-" => BinaryOperator::Subtract,
};

FactorOperator: BinaryOperator = {
    "*" => BinaryOperator::Multiply,
    "/" => BinaryOperator::Divide,
    "%" => BinaryOperator::Modulo,
};

UnaryOperator: UnaryOperator = {
    "!" => UnaryOperator::Not,
};

BoolLiteral: bool = {
    "true" => true,
    "false" => false,
};

Term: Box<Expression> = {
    Number => Box::new(Expression::Number(<>)),
    BoolLiteral => Box::new(Expression::Bool(<>)),
    Identifier => Box::new(Expression::VariableLookup(<>)),
    "(" <Expression> ")",
    "[" <OptionalFinalSeparatorList<Expression, ",">> "]" => Box::new(Expression::ArrayLiteral(<>)),
    r"\x22[^\x22]*\x22" => {
        let s = <>;
        Box::new(Expression::StringLiteral(String::from(&s[1..(s.len() - 1)])))
    }
};


// =============================== Primitive =====================================


Number: i32 = {
    _Number => i32::from_str(<>).unwrap()
};

Identifier: String = {
    _Identifier => format!("{}", <>)
};
