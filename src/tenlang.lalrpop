use std::str::FromStr;
use crate::abstract_syntax::*;

grammar;

// =============================== Lexer Precedence =====================================

match {
    r"[0-9]+" => _Number,
    "true", "false",
    "return",
    "(", ")", "{", "}", "[",  "]", "|",
    ";", ",", ":", "::", "->",
    "=",
    "!",
    "+", "-", "*", "/", "&&", "||",
    "**", "%",
    "==", "!=", ">", ">=", "<", "<=",
    "let", "var",
    "fun",
} else {
    r"[a-zA-Z_]\w*" => _Identifier,
    _
}

// =============================== Primitive =====================================

Number: i32 = {
    _Number => i32::from_str(<>).unwrap()
};

BoolLiteral: bool = {
    "true" => true,
    "false" => false,
};

Identifier: String = {
    _Identifier => format!("{}", <>)
};

// =============================== Global =====================================


pub Program: Program = {
    <stmts: (<GlobalStatement>)*> => Program { global_statements: stmts }
};

pub GlobalStatement: Box<GlobalStatement> = {
    Function => Box::new(GlobalStatement::FunctionDeclaration(<>)),
};

Function: Box<Function> = {
    "fun" <target_type: (<TypeDeclaration> ".")?> <identifier: Identifier> "(" <parameters: OptionalFinalSeparatorList<Parameter, ",">> ")" <return_type: ("->" <TypeDeclaration>)?> "::" <body: FunctionBody> => Box::new(Function {
        target_type, identifier, parameters, return_type, body
    }),
}

FunctionBody: Vec<Box<Statement>> = {
    "{" <(<Statement> ";")*> "}",
    <Expression> ";" => vec![Box::new(Statement::Expression(<>))],
}

Parameter: Box<Parameter> = {
    <internal_name: Identifier> ":" <param_type: TypeDeclaration> => Box::new(Parameter {
        key: ParameterKey::Name(internal_name.clone()), internal_name, param_type
    }),
    <key: Number> <internal_name: Identifier> ":" <param_type: TypeDeclaration> => Box::new(Parameter {
        key: ParameterKey::Int(key), internal_name, param_type
    }),
    <key: Identifier> <internal_name: Identifier> ":" <param_type: TypeDeclaration> => Box::new(Parameter {
        key: ParameterKey::Name(key), internal_name, param_type
    }),
}

// =============================== Type =====================================


TypeDeclaration: Box<TypeDeclaration> = {
    Identifier => Box::new(TypeDeclaration::Identifier(<>)),
    <TypeDeclaration> "[" <OptionalFinalSeparatorList<Expression, ",">> "]" => Box::new(TypeDeclaration::NDArray(<>))
}


// =============================== Statement =====================================


pub Statement: Box<Statement> = {
    <mutability: VariableDeclarationMutability> <identifier: Identifier> ":" <type_declaration: TypeDeclaration> "=" <expression: Expression> => Box::new(Statement::VariableDeclaration { mutability, identifier, type_declaration: Some(type_declaration), expression }),
    <mutability: VariableDeclarationMutability> <identifier: Identifier> "=" <expression: Expression> => Box::new(Statement::VariableDeclaration { mutability, identifier, type_declaration: None, expression }),
    <i: Identifier> "=" <e: Expression> => Box::new(Statement::VariableAssignment(i, e)),
    "return" <Expression> => Box::new(Statement::Return(Some(<>))),
    "return" => Box::new(Statement::Return(None)),
    Expression => Box::new(Statement::Expression(<>)),
};

VariableDeclarationMutability: Mutability = {
    "let" => Mutability::Immutable,
    "var" => Mutability::Mutable,
};

// =============================== Expression =====================================

Expression: Box<Expression> = OrPrecedenceGroup;
OrPrecedenceGroup = LeftAssociativeBinaryOperator<OrOperator, AndPrecedenceGroup>;
AndPrecedenceGroup = LeftAssociativeBinaryOperator<AndOperator, ComparisonPrecedenceGroup>;
ComparisonPrecedenceGroup = LeftAssociativeBinaryOperator<ComparisonOperator, AdditionPrecedenceGroup>;
AdditionPrecedenceGroup = LeftAssociativeBinaryOperator<SumOperator, MultiplicationPrecedenceGroup>;
MultiplicationPrecedenceGroup = LeftAssociativeBinaryOperator<FactorOperator, ExponentiationPrecedenceGroup>;
ExponentiationPrecedenceGroup = RightAssociativeBinaryOperator<ExponentiationOperator, UnaryOperatorPrecedenceGroup>;
UnaryOperatorPrecedenceGroup = LeftUnaryOperator<UnaryOperator, FunctionCallPrecedenceGroup>;
FunctionCallPrecedenceGroup = FunctionCallExpression<EquivalenceEqualityPrecedenceGroup>;
EquivalenceEqualityPrecedenceGroup = EquivalenceEquality<Term>;

Term: Box<Expression> = {
    Number => Box::new(Expression::Number(<>)),
    BoolLiteral => Box::new(Expression::Bool(<>)),
    Identifier => Box::new(Expression::VariableLookup(<>)),
    "[" <OptionalFinalSeparatorList<Expression, ",">> "]" => Box::new(Expression::ArrayLiteral(<>)),
    "(" <Expression> ")",
    r"\x22[^\x22]*\x22" => {
        let s = <>;
        Box::new(Expression::StringLiteral(String::from(&s[1..(s.len() - 1)])))
    },
};

PassedArgument: Box<PassedArgument> = {
    <name: Number> ":" <value: Expression> => Box::new(PassedArgument { key: Some(ParameterKey::Int(name)), value }),
    <name: Identifier> ":" <value: Expression> => Box::new(PassedArgument { key: Some(ParameterKey::Name(name)), value }),
    <value: Expression> => Box::new(PassedArgument { key: None, value })
}

ExponentiationOperator: BinaryOperator = {
    "**" => BinaryOperator::Exponentiate,
};

OrOperator: BinaryOperator = {
    "||" => BinaryOperator::Or,
};

AndOperator: BinaryOperator = {
    "&&" => BinaryOperator::And,
};

SumOperator: BinaryOperator = {
    "+" => BinaryOperator::Add,
    "-" => BinaryOperator::Subtract,
};

FactorOperator: BinaryOperator = {
    "*" => BinaryOperator::Multiply,
    "/" => BinaryOperator::Divide,
    "%" => BinaryOperator::Modulo,
};

ComparisonOperator: BinaryOperator = {
    "==" => BinaryOperator::EqualTo,
    "!=" => BinaryOperator::NotEqualTo,

    ">" => BinaryOperator::GreaterThan,
    ">=" => BinaryOperator::GreaterThanOrEqualTo,
    "<" => BinaryOperator::LesserThan,
    "<=" => BinaryOperator::LesserThanOrEqualTo,
}

UnaryOperator: UnaryOperator = {
    "+" => UnaryOperator::Positive,
    "-" => UnaryOperator::Negative,
    "!" => UnaryOperator::Not,
};

FunctionCallExpression<NextOperatorLevel>: Box<Expression> = {
    <FunctionCallExpression<NextOperatorLevel>> "(" <OptionalFinalSeparatorList<PassedArgument, ",">> ")" => Box::new(Expression::FunctionCall(FunctionCallType::Call, <>)),
    <FunctionCallExpression<NextOperatorLevel>> "[" <OptionalFinalSeparatorList<PassedArgument, ",">> "]" => Box::new(Expression::FunctionCall(FunctionCallType::Subscript, <>)),
    <FunctionCallExpression<NextOperatorLevel>> "." <Identifier> => Box::new(Expression::MemberLookup(<>)),
    NextOperatorLevel
}

EquivalenceEquality<NextOperatorLevel>: Box<Expression> = {
    <EquivalenceEquality<NextOperatorLevel>> "|",
    <NextOperatorLevel>,
}


// =============================== Util =====================================

OptionalFinalSeparatorList<Element, Separator>: Vec<Element> = {
    <v0: (<Element> Separator)*> <e1: Element?> => v0.into_iter().chain(e1).collect()
};

AtLeastTwoElementsSeparatorList<Element, Separator>: Vec<Element> = {
    <v0: (<Element> Separator)+> <e1: Element> => v0.into_iter().chain([e1]).collect()
};

LeftAssociativeBinaryOperator<Operator, NextOperatorLevel>: Box<Expression> = {
    <lhs: LeftAssociativeBinaryOperator<Operator, NextOperatorLevel>> <operator: Operator> <rhs: NextOperatorLevel> => Box::new(Expression::BinaryOperator { lhs, operator, rhs }),
    NextOperatorLevel
};

RightAssociativeBinaryOperator<Operator, NextOperatorLevel>: Box<Expression> = {
    <lhs: NextOperatorLevel> <operator: Operator> <rhs: RightAssociativeBinaryOperator<Operator, NextOperatorLevel>> => Box::new(Expression::BinaryOperator { lhs, operator, rhs }),
    NextOperatorLevel
};

LeftUnaryOperator<Operator, NextOperatorLevel>: Box<Expression> = {
    <operator: Operator> <expression: LeftUnaryOperator<Operator, NextOperatorLevel>>  => Box::new(Expression::UnaryOperator(operator, expression)),
    NextOperatorLevel
};
