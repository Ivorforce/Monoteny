use std::str::FromStr;
use crate::abstract_syntax::{Program, Extension, Expression, Opcode, Statement, GlobalStatement, MemberStatement, Mutability, Function, ParameterDeclaration, TypeDeclaration, PassedArgument, FunctionCallType};

grammar;

// =============================== Util =====================================

OptionalFinalSeparatorList<E,S>: Vec<E> =
    <v0:(<E> S)*> <e1:E?> =>
        v0.into_iter().chain(e1).collect();

match {
    r"[0-9]+" => _Number,
    "return",
    "(", ")", "{", "}", "[",  "]",
    ";", ",", ":",
    "=", "?",
    "+", "-", "*", "/",
    "let", "var",
    "fn", "extension",
} else {
    r"[a-zA-Z_]\w*" => _Identifier,
    _
}


// =============================== Global =====================================


pub Program: Program = {
    <stmts: (<GlobalStatement>)*> => Program { global_statements: stmts }
};

pub GlobalStatement: Box<GlobalStatement> = {
    Function => Box::new(GlobalStatement::FunctionDeclaration(<>)),
    Extension => Box::new(GlobalStatement::Extension(<>))
};

Function: Box<Function> = {
    "fn" <identifier: Identifier> "(" <parameters: OptionalFinalSeparatorList<ParameterDeclaration, ",">> ")" <return_type: ("->" <TypeDeclaration>)?> "{" <body: (<Statement> ";")*> "}" => Box::new(Function {
        identifier, parameters, return_type, body
    }),
}

ParameterDeclaration: Box<ParameterDeclaration> = {
    <name: Identifier> ":" <param_type: TypeDeclaration> => Box::new(ParameterDeclaration {
        internal_name: name.clone(), external_name: name.clone(), param_type
    }),
    <external_name: Identifier> <internal_name: Identifier> ":" <param_type: TypeDeclaration> => Box::new(ParameterDeclaration {
        internal_name, external_name, param_type
    }),
}

// =============================== Member =====================================

pub Extension: Box<Extension> = {
    "extension" <type_declaration: TypeDeclaration> "{" <statements: (<MemberStatement>)*> "}" => Box::new(Extension {
        type_declaration, statements
    })
};

pub MemberStatement: Box<MemberStatement> = {
    Function => Box::new(MemberStatement::FunctionDeclaration(<>)),
};

// =============================== Type =====================================


TypeDeclaration: Box<TypeDeclaration> = {
    Identifier => Box::new(TypeDeclaration::Identifier(<>)),
    <Identifier> "[" <OptionalFinalSeparatorList<Expression, ",">> "]" => Box::new(TypeDeclaration::NDArray(<>))
}


// =============================== Body =====================================


pub Statement: Box<Statement> = {
    <m: VariableDeclarationMutability> <i: Identifier> "=" <e: Expression> => Box::new(Statement::VariableDeclaration(m, i, None, e)),
    <m: VariableDeclarationMutability> <i: Identifier> ":" <t: TypeDeclaration> "=" <e: Expression> => Box::new(Statement::VariableDeclaration(m, i, Some(t), e)),
    "return" <Expression> => Box::new(Statement::Return(<>)),
    Expression => Box::new(Statement::Expression(<>)),
};

BinaryOperator<Operator, NextOperatorLevel>: Box<Expression> = {
    BinaryOperator<Operator, NextOperatorLevel> Operator NextOperatorLevel => Box::new(Expression::BinaryOperator(<>)),
    NextOperatorLevel
};

Expression: Box<Expression> = FunctionCallElement;

FunctionCallElement = {
    <Expression> "(" <OptionalFinalSeparatorList<PassedArgument, ",">> ")" => Box::new(Expression::FunctionCall(FunctionCallType::Call, <>)),
    <Expression> "[" <OptionalFinalSeparatorList<PassedArgument, ",">> "]" => Box::new(Expression::FunctionCall(FunctionCallType::Subscript, <>)),
    <Expression> "." <Identifier> => Box::new(Expression::MemberLookup(<>)),
    SumElement
}
SumElement = BinaryOperator<SumOperator, MultiplicationElement>;
MultiplicationElement = BinaryOperator<FactorOperator, Term>;

PassedArgument: Box<PassedArgument> = {
    <name: Identifier> ":" <value: Expression> => Box::new(PassedArgument { name: Some(name), value }),
    <value: Expression> => Box::new(PassedArgument { name: None, value })
}

SumOperator: Opcode = { // (3)
    "+" => Opcode::Add,
    "-" => Opcode::Subtract,
};

FactorOperator: Opcode = {
    "*" => Opcode::Multiply,
    "/" => Opcode::Divide,
};

VariableDeclarationMutability: Mutability = {
    "let" => Mutability::Immutable,
    "var" => Mutability::Mutable,
};

Term: Box<Expression> = {
    Num => Box::new(Expression::Number(<>)),
    Identifier => Box::new(Expression::VariableLookup(<>)),
    "(" <Expression> ")",
    "[" <OptionalFinalSeparatorList<Expression, ",">> "]" => Box::new(Expression::ArrayLiteral(<>)),
};


// =============================== Primitive =====================================


Num: i32 = {
    _Number => i32::from_str(<>).unwrap()
};

Identifier: String = {
    _Identifier => format!("{}", <>)
};
